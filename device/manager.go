package device

import (
	"errors"
	"fmt"
	"sync"

	"github.com/kushsharma/coffee-dunzo/models"
	log "github.com/sirupsen/logrus"
)

// Manager provides few APIs to handle user requested device
// it supports multiple outlets at a time to serve multiple
// requests at a time.
// Also supports checking if device stock is going below certain threshold
type Manager struct {
	minimumStock models.ItemQuantity
	mixers       []models.Mixer
	requestQueue chan models.Item
	servedQ      chan models.Item
	errQ         chan error
	stock        models.Store
	wg           *sync.WaitGroup
	finished     bool
	logger       *log.Logger
}

// Stop sends a signal to stop taking anymore requests
func (m *Manager) Stop() {
	m.logger.Info("stopping device")
	close(m.requestQueue)
	m.wg.Wait()
	close(m.errQ)
	close(m.servedQ)
	m.mixers = nil
	m.finished = true
}

func (m *Manager) CreateOutlet(mixer models.Mixer) {
	m.mixers = append(m.mixers, mixer)
	go func() {
		m.wg.Add(1)
		mixer.Run(m.requestQueue, m.servedQ, m.errQ)
		m.wg.Done()
	}()
}

// RequestItem requests from device to prepare an item
func (m *Manager) RequestItem(item models.Item) error {
	if m.finished {
		return errors.New("cannot request new item after stopping machine")
	}
	m.requestQueue <- item
	return nil
}

// FillIngrident adds item ingrident to device stock
func (m *Manager) FillIngrident(name models.Ingrident, quantity models.Quantiy) error {
	return m.stock.Add(name, quantity)
}

// CheckRefill provides a list of ingridents that are below
// warning threshold and needs to be refilled for proper functioning
func (m *Manager) CheckRefill() []models.Ingrident {
	needsRefil := []models.Ingrident{}
	currentStock := m.stock.Status()
	for ingrident, threshold := range m.minimumStock {
		if quant, ok := currentStock[ingrident]; !ok || threshold > quant {
			needsRefil = append(needsRefil, ingrident)
		}
	}
	return needsRefil
}

// processErrorAccumulator accumulates all the errors generated by outlets
func (m *Manager) processErrorAccumulator() {
	for err := range m.errQ {
		m.logger.Info(err)
	}
}

// processOrderAccumulator accumulates all the prepared item generated by outlets
func (m *Manager) processOrderAccumulator() {
	for item := range m.servedQ {
		m.logger.Info(fmt.Sprintf("%s is prepared", item))
	}
}

func NewManager(minStockWarning models.ItemQuantity, store models.Store, logger *log.Logger) *Manager {
	m := &Manager{
		minimumStock: minStockWarning,
		requestQueue: make(chan models.Item),
		errQ:         make(chan error),
		servedQ:      make(chan models.Item, 10),
		stock:        store,
		mixers:       []models.Mixer{},
		wg:           &sync.WaitGroup{},
		finished:     false,
		logger:       logger,
	}
	go m.processErrorAccumulator()
	go m.processOrderAccumulator()
	return m
}
